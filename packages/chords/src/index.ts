export type ChordShape = {
  name: string;
  positions: number[]; // low E to high E, -1 mute, 0 open, >0 fret
  fingers?: number[]; // optional finger hints
  baseFret?: number; // optional base fret for diagrams
};

type ChordDbShape = {
  positions: number[];
  fingers?: number[];
  baseFret?: number;
};

// Open + very common shapes. Anything not in this dictionary will fall back to a
// barre-shape generator, so we can support a huge variety of chords.
const SHAPES: Record<string, ChordShape> = {
  // Major / minor
  C: { name: 'C', positions: [-1, 3, 2, 0, 1, 0] },
  Cm: { name: 'Cm', positions: [-1, 3, 5, 5, 4, 3], baseFret: 3 },
  D: { name: 'D', positions: [-1, -1, 0, 2, 3, 2] },
  Dm: { name: 'Dm', positions: [-1, -1, 0, 2, 3, 1] },
  E: { name: 'E', positions: [0, 2, 2, 1, 0, 0] },
  Em: { name: 'Em', positions: [0, 2, 2, 0, 0, 0] },
  F: { name: 'F', positions: [1, 3, 3, 2, 1, 1], baseFret: 1 },
  G: { name: 'G', positions: [3, 2, 0, 0, 0, 3] },
  A: { name: 'A', positions: [-1, 0, 2, 2, 2, 0] },
  Am: { name: 'Am', positions: [-1, 0, 2, 2, 1, 0] },
  B: { name: 'B', positions: [-1, 2, 4, 4, 4, 2], baseFret: 2 },
  Bm: { name: 'Bm', positions: [-1, 2, 4, 4, 3, 2], baseFret: 2 },

  // 7 / maj7 / m7 (open)
  C7: { name: 'C7', positions: [-1, 3, 2, 3, 1, 0] },
  Cmaj7: { name: 'Cmaj7', positions: [-1, 3, 2, 0, 0, 0] },
  D7: { name: 'D7', positions: [-1, -1, 0, 2, 1, 2] },
  Dmaj7: { name: 'Dmaj7', positions: [-1, -1, 0, 2, 2, 2] },
  Dm7: { name: 'Dm7', positions: [-1, -1, 0, 2, 1, 1] },
  E7: { name: 'E7', positions: [0, 2, 0, 1, 0, 0] },
  Emaj7: { name: 'Emaj7', positions: [0, 2, 1, 1, 0, 0] },
  Em7: { name: 'Em7', positions: [0, 2, 0, 0, 0, 0] },
  G7: { name: 'G7', positions: [3, 2, 0, 0, 0, 1] },
  A7: { name: 'A7', positions: [-1, 0, 2, 0, 2, 0] },
  Amaj7: { name: 'Amaj7', positions: [-1, 0, 2, 1, 2, 0] },
  Am7: { name: 'Am7', positions: [-1, 0, 2, 0, 1, 0] },

  // sus / add9 (open)
  Dsus2: { name: 'Dsus2', positions: [-1, -1, 0, 2, 3, 0] },
  Dsus4: { name: 'Dsus4', positions: [-1, -1, 0, 2, 3, 3] },
  Esus4: { name: 'Esus4', positions: [0, 2, 2, 2, 0, 0] },
  Asus4: { name: 'Asus4', positions: [-1, 0, 2, 2, 3, 0] },
  Cadd9: { name: 'Cadd9', positions: [-1, 3, 2, 0, 3, 3] },
  Dadd9: { name: 'Dadd9', positions: [-1, -1, 0, 2, 3, 0] },
  Eadd9: { name: 'Eadd9', positions: [0, 2, 2, 1, 0, 2] },
  Gadd9: { name: 'Gadd9', positions: [3, 2, 0, 0, 3, 3] },
  Aadd9: { name: 'Aadd9', positions: [-1, 0, 2, 4, 0, 0] }
};

// Large chord database generated from an open-source dataset (JSON).
// This keeps all variants per chord name so we can evolve the UI later.
// The data file is generated by scripts/build-chords-db (see repo docs).
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import CHORD_DB_RAW from './chords-db.json';

const CHORD_DB = CHORD_DB_RAW as Record<string, ChordDbShape[]>;

// Ukulele chord database (G C E A). Generated from an MIT licensed dataset
// using scripts/build-ukulele-db.mjs (kept as JSON for Metro/Next bundling).
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import UKULELE_DB_RAW from './ukulele-db.json';

const UKULELE_DB = UKULELE_DB_RAW as Record<string, ChordDbShape[]>;

export type Instrument = 'guitar' | 'ukulele';

type ShapeKind = 'major' | 'minor' | '7' | 'maj7' | 'm7' | 'sus4' | 'sus2' | 'add9' | 'madd9';

const NOTE_TO_SEMITONE: Record<string, number> = {
  C: 0,
  'C#': 1,
  Db: 1,
  D: 2,
  'D#': 3,
  Eb: 3,
  E: 4,
  F: 5,
  'F#': 6,
  Gb: 6,
  G: 7,
  'G#': 8,
  Ab: 8,
  A: 9,
  'A#': 10,
  Bb: 10,
  B: 11
};

function clamp(n: number, min: number, max: number) {
  return Math.max(min, Math.min(max, n));
}

function normalizeRoot(root: string) {
  const match = root.trim().match(/^([A-G])([#b])?$/u);
  if (!match) return root.trim();
  return `${match[1].toUpperCase()}${match[2] ?? ''}`;
}

function normalizeChordNameForDb(raw: string): string {
  const trimmed = String(raw ?? '').trim().replace(/\s+/gu, '');
  if (!trimmed) return trimmed;

  const noParen = trimmed.replace(/\(.*?\)/gu, '');
  const match = noParen.match(/^([A-Ga-g])([#b])?(.*)$/u);
  if (!match) return noParen;

  const root = `${match[1].toUpperCase()}${match[2] ?? ''}`;
  let suffix = String(match[3] ?? '');

  suffix = suffix.replace(/º|°/gu, 'dim').replace(/ø/gu, 'm7b5');
  suffix = suffix.replace(/7M/giu, 'maj7').replace(/M7/gu, 'maj7');

  if (suffix.toLowerCase() === 'major') suffix = '';
  if (suffix.toLowerCase().startsWith('major')) suffix = `maj${suffix.slice(5)}`;
  if (suffix.toLowerCase() === 'minor') suffix = 'm';
  if (suffix.toLowerCase().startsWith('minor')) suffix = `m${suffix.slice(5)}`;

  return `${root}${suffix}`;
}

function chordDbCandidates(name: string): string[] {
  const trimmed = String(name ?? '').trim();
  if (!trimmed) return [];

  const base = normalizeChordNameForDb(trimmed);
  const candidates = new Set<string>();

  candidates.add(base);

  if (base.includes('/')) {
    const [main] = base.split('/');
    if (main) candidates.add(main);
  }

  return Array.from(candidates);
}

function selectPreferredShape(shapes: ChordDbShape[], name: string): ChordShape {
  const withScores = shapes.map((shape) => {
    const baseFret = shape.baseFret ?? Math.min(...shape.positions.filter((p) => p > 0));
    const muted = shape.positions.filter((p) => p < 0).length;
    const maxFret = Math.max(...shape.positions.filter((p) => p > 0), 0);
    const score = (baseFret || 1) * 100 + muted * 10 + maxFret;
    return { shape, score, baseFret };
  });

  withScores.sort((a, b) => a.score - b.score);
  const best = withScores[0]?.shape ?? shapes[0];
  return { name, positions: best.positions, ...(best.fingers ? { fingers: best.fingers } : null), ...(best.baseFret ? { baseFret: best.baseFret } : null) };
}

function parseChordForShape(name: string): { root: string; kind: ShapeKind } | null {
  const raw = String(name ?? '').trim();
  if (!raw) return null;

  // Slash chords: keep only the main chord for diagram purposes.
  const main = raw.split('/')[0] ?? raw;

  const match = main.match(/^([A-G])([#b])?(.*)$/u);
  if (!match) return null;

  const root = normalizeRoot(`${match[1]}${match[2] ?? ''}`);
  let suffix = String(match[3] ?? '');

  // Remove some common ornamentation to improve matching.
  suffix = suffix.replace(/\s+/gu, '');
  suffix = suffix.replace(/\(.*?\)/gu, ''); // drop (11), (9), etc
  const lower = suffix.toLowerCase();

  // Support the most common charting conventions:
  // - "A9" usually means A(add9) in BR charts (dominant 9 is written as A7(9)).
  // - "m" means minor, except "maj".
  const isMinor = /m/.test(lower) && !/maj/.test(lower) && !/dim/.test(lower);
  const isMaj7 = /maj7/.test(lower);
  const isM7 = !isMaj7 && /m7/.test(lower);
  const is7 = !isMaj7 && !isM7 && /7/.test(lower);
  const isSus4 = /sus4/.test(lower);
  const isSus2 = /sus2/.test(lower);

  const has9 = /9/.test(lower);
  const isAdd9 = /add9/.test(lower) || (has9 && !is7 && !isMaj7 && !isM7);

  if (isMaj7) return { root, kind: isMinor ? 'minor' : 'maj7' };
  if (isM7) return { root, kind: 'm7' };
  if (is7) return { root, kind: isMinor ? 'm7' : '7' };
  if (isSus4) return { root, kind: 'sus4' };
  if (isSus2) return { root, kind: 'sus2' };
  if (isAdd9) return { root, kind: isMinor ? 'madd9' : 'add9' };
  return { root, kind: isMinor ? 'minor' : 'major' };
}

function fretForRootOnString(root: string, open: string) {
  const rootSemi = NOTE_TO_SEMITONE[root];
  const openSemi = NOTE_TO_SEMITONE[open];
  if (rootSemi === undefined || openSemi === undefined) return null;
  return (rootSemi - openSemi + 12) % 12;
}

function baseFretFromPositions(positions: number[]) {
  const fretted = positions.filter((p) => p > 0);
  if (!fretted.length) return undefined;
  const minFret = Math.min(...fretted);
  return minFret > 1 ? minFret : undefined;
}

function buildEShape(fret: number, kind: ShapeKind): number[] {
  const f = clamp(fret, 0, 12);
  switch (kind) {
    case 'major':
      return [f, f + 2, f + 2, f + 1, f, f];
    case 'minor':
      return [f, f + 2, f + 2, f, f, f];
    case '7':
      return [f, f + 2, f, f + 1, f, f];
    case 'maj7':
      return [f, f + 2, f + 1, f + 1, f, f];
    case 'm7':
      return [f, f + 2, f, f, f, f];
    case 'sus4':
      return [f, f + 2, f + 2, f + 2, f, f];
    case 'sus2':
      // Closest practical: treat as add9-ish on the top string.
      return [f, f + 2, f + 2, f + 1, f, f + 2];
    case 'add9':
      return [f, f + 2, f + 2, f + 1, f, f + 2];
    case 'madd9':
      return [f, f + 2, f + 2, f, f, f + 2];
    default:
      return [f, f + 2, f + 2, f + 1, f, f];
  }
}

function buildAShape(fret: number, kind: ShapeKind): number[] {
  const f = clamp(fret, 0, 12);
  switch (kind) {
    case 'major':
      return [-1, f, f + 2, f + 2, f + 2, f];
    case 'minor':
      return [-1, f, f + 2, f + 2, f + 1, f];
    case '7':
      return [-1, f, f + 2, f, f + 2, f];
    case 'maj7':
      return [-1, f, f + 2, f + 1, f + 2, f];
    case 'm7':
      return [-1, f, f + 2, f, f + 1, f];
    case 'sus4':
      return [-1, f, f + 2, f + 2, f + 3, f];
    case 'sus2':
      return [-1, f, f + 2, f + 2, f, f];
    case 'add9':
      // A-shape add9 varies a lot; a stable fallback is the major shape.
      return [-1, f, f + 2, f + 2, f + 2, f];
    case 'madd9':
      return [-1, f, f + 2, f + 2, f + 1, f];
    default:
      return [-1, f, f + 2, f + 2, f + 2, f];
  }
}

function generateShape(name: string): ChordShape | null {
  const parsed = parseChordForShape(name);
  if (!parsed) return null;

  const { root, kind } = parsed;
  const eFret = fretForRootOnString(root, 'E');
  const aFret = fretForRootOnString(root, 'A');
  if (eFret === null || aFret === null) return null;

  // Pick the lower-position barre family.
  const useA = aFret <= eFret;
  const positions = useA ? buildAShape(aFret, kind) : buildEShape(eFret, kind);

  const baseFret = baseFretFromPositions(positions);
  return { name, positions, baseFret };
}

export function simplifyChordName(name: string): string {
  const parsed = parseChordForShape(name);
  if (!parsed) return name;
  const { root, kind } = parsed;
  switch (kind) {
    case 'major':
      return root;
    case 'minor':
      return `${root}m`;
    case '7':
      return `${root}7`;
    case 'maj7':
      return `${root}maj7`;
    case 'm7':
      return `${root}m7`;
    case 'sus4':
      return `${root}sus4`;
    case 'sus2':
      return `${root}sus2`;
    case 'add9':
      return `${root}add9`;
    case 'madd9':
      return `${root}madd9`;
    default:
      return root;
  }
}

export function getChordShape(name: string): ChordShape | null {
  const shapes = getChordShapes(name);
  if (!shapes.length) return null;
  return shapes[0];
}

export function getChordShapes(name: string): ChordShape[] {
  if (!name) return [];

  if (SHAPES[name]) return [SHAPES[name]];

  const simplified = simplifyChordName(name);
  if (SHAPES[simplified]) return [SHAPES[simplified]];

  for (const candidate of chordDbCandidates(name)) {
    const variants = CHORD_DB[candidate];
    if (!variants || !variants.length) continue;
    const preferred = selectPreferredShape(variants, candidate);
    const out: ChordShape[] = [];
    const seen = new Set<string>();
    const pushShape = (shape: ChordShape) => {
      const sig = shape.positions.join(',');
      if (seen.has(sig)) return;
      seen.add(sig);
      out.push(shape);
    };
    pushShape(preferred);
    for (const v of variants) {
      pushShape({ name: candidate, ...v });
    }
    return out;
  }

  const generated = generateShape(name);
  return generated ? [generated] : [];
}

function getUkuleleChordShapes(name: string): ChordShape[] {
  if (!name) return [];

  for (const candidate of chordDbCandidates(name)) {
    const variants = UKULELE_DB[candidate];
    if (!variants || !variants.length) continue;
    const preferred = selectPreferredShape(variants, candidate);
    const out: ChordShape[] = [];
    const seen = new Set<string>();
    const pushShape = (shape: ChordShape) => {
      const sig = shape.positions.join(',');
      if (seen.has(sig)) return;
      seen.add(sig);
      out.push(shape);
    };
    pushShape(preferred);
    for (const v of variants) {
      pushShape({ name: candidate, ...v });
    }
    return out;
  }

  return [];
}

export function getChordShapeForInstrument(name: string, instrument: Instrument = 'guitar'): ChordShape | null {
  const shapes = getChordShapesForInstrument(name, instrument);
  if (!shapes.length) return null;
  return shapes[0];
}

export function getChordShapesForInstrument(name: string, instrument: Instrument = 'guitar'): ChordShape[] {
  if (instrument === 'ukulele') return getUkuleleChordShapes(name);
  return getChordShapes(name);
}

export function listChordNames(): string[] {
  return Array.from(new Set([...Object.keys(SHAPES), ...Object.keys(CHORD_DB)]));
}

export function renderChordSvg(shape: ChordShape, options?: { leftHanded?: boolean }): string {
  const width = 140;
  const height = 180;
  const paddingX = 20;
  const paddingY = 26;
  const stringCount = 6;
  const fretCount = 5;
  const stringSpacing = (width - paddingX * 2) / (stringCount - 1);
  const fretSpacing = (height - paddingY * 2) / fretCount;

  const strings = Array.from({ length: stringCount }, (_, index) => {
    const x = paddingX + index * stringSpacing;
    return `<line x1="${x}" y1="${paddingY}" x2="${x}" y2="${height - paddingY}" stroke="#1f2937" stroke-width="2" />`;
  }).join('');

  const frets = Array.from({ length: fretCount + 1 }, (_, index) => {
    const y = paddingY + index * fretSpacing;
    const strokeWidth = index === 0 ? 4 : 2;
    return `<line x1="${paddingX}" y1="${y}" x2="${width - paddingX}" y2="${y}" stroke="#1f2937" stroke-width="${strokeWidth}" />`;
  }).join('');

  const markers = shape.positions
    .map((pos, stringIndex) => {
      const x = paddingX + stringIndex * stringSpacing;
      if (pos === -1) {
        return `<text x="${x}" y="${paddingY - 10}" text-anchor="middle" font-size="12" fill="#6b7280">x</text>`;
      }
      if (pos === 0) {
        return `<circle cx="${x}" cy="${paddingY - 8}" r="5" fill="none" stroke="#1f2937" stroke-width="2" />`;
      }
      const fret = shape.baseFret ? pos - shape.baseFret + 1 : pos;
      const y = paddingY + (fret - 0.5) * fretSpacing;
      return `<circle cx="${x}" cy="${y}" r="6" fill="#111827" />`;
    })
    .join('');

  const baseFretLabel = shape.baseFret && shape.baseFret > 1
    ? `<text x="${width - paddingX + 6}" y="${paddingY + fretSpacing}" font-size="12" fill="#6b7280">${shape.baseFret}fr</text>`
    : '';

  const flip = options?.leftHanded ? 'scale(-1,1) translate(-140,0)' : '';

  return `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">
  <g transform="${flip}">
    ${strings}
    ${frets}
    ${markers}
    ${baseFretLabel}
  </g>
</svg>`;
}
